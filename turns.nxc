// vim:ft=c:ts=2:sts=2:sw=2:et

#include "params.nxc"
#define SWINGTURN90 (SWINGTURN45 * 2)
#define SWINGTURN45 1185
#define POINTTURN90 600
#define POINTTURNNET 50
#define POINTTURN45 320

#define POWER_TURN_MAIN POWER_MAX
#define POWER_TURN_OPPOSITE 70

// this is in degrees
int orientation = 0;

inline int mod(int a, int b) {
  int r = a % b;
  return r < 0 ? r + b : r;
}

void swingTurn(bool direction, long amount) {
  byte         output = direction == DIRECTION_LEFT ? OUT_RIGHT : OUT_LEFT; 
  byte oppositeOutput = direction == DIRECTION_LEFT ? OUT_LEFT : OUT_RIGHT;
  long initialRotationCount = MotorRotationCount(output);

  OnFwd(output, POWER_TURN_MAIN);
  OnFwd(oppositeOutput, POWER_TURN_OPPOSITE);

  until (MotorRotationCount(output) - initialRotationCount > amount);

  Off(OUT_MOVE);
}

void pointTurn(bool direction, long amount) {
  char        turnpct = direction == DIRECTION_LEFT ? TURNPCT_LEFT : TURNPCT_RIGHT;
  byte countingOutput = direction == DIRECTION_LEFT ? OUT_RIGHT : OUT_LEFT;

  long initialRotationCount = MotorRotationCount(countingOutput);

  OnFwdSync(OUT_MOVE, POWER_MAX, turnpct);

  until (MotorRotationCount(countingOutput) - initialRotationCount > amount);

  Off(OUT_MOVE);
}

void updateOrientation(int val) {
  orientation += val;
  orientation = mod(orientation + 180, 360) - 180;
}
void closeTurn(bool direction) {
  pointTurn(direction, POINTTURN45); 

  updateOrientation(direction == DIRECTION_RIGHT ? 45 : -45);
  LOG(NumToStr(orientation));

  swingTurn(direction, SWINGTURN45);

  updateOrientation(direction == DIRECTION_RIGHT ? 45 : -45);
  LOG(NumToStr(orientation));
}


inline bool isLookingAt(int direction) {
  return abs(mod(orientation + 180 - direction, 360) - 180) < 15;
}

